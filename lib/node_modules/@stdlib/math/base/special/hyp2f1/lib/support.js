/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var abs = require( '@stdlib/math/base/special/abs' );
var round = require( '@stdlib/math/base/special/round' );
var PINF = require( '@stdlib/constants/math/float64-pinf' );


// VARIABLES //

var EPS = 1.0e-13;
var MAX_ITERATIONS = 10000;
var MACHEP = 0.0;

/**
* Evaluates the Gaussian hypergeometric function.
*
* @private
* @param {number} a - input value
* @param {number} b - input value
* @param {number} c - input value
* @param {number} x - input value
* @param {Object} loss - loss
* @returns {number} function value
*
*/
function hys2f1( a, b, c, x, loss ) {
	var intflag;
	var umax;
	var ib;
	var u;
	var s;
	var m;
	var k;
	var h;
	var g;
	var f;
	var i;

	ib = 0;
	intflag = 0;

	if ( abs( b ) > abs( a ) ) {
		f = b;
		b = a;
		a = f;
	}

	ib = round( b );

	if ( abs( b - ib ) < EPS && ib <= 0 && abs( b ) < abs( a ) ) {
		f = b;
		b = a;
		a = f;
		intflag = 1;
	}

	if ( ( abs( a ) > abs( c ) + 1 || intflag === 1 ) &&
		abs( c-a ) > 2 && abs( a ) > 2 ) {
		return hyp2f1ra( a, b, c, x, loss );
	}

	i = 0;
	umax = 0.0;
	f = a;
	g = b;
	h = c;
	s = 1.0;
	u = 1.0;
	k = 0.0;

	do {
		if ( abs( h ) < EPS ) {
			loss.v = 1.0;
			return PINF;
		}
		m = k + 1.0;
		u *= ( ( f + k ) * ( g + k ) * x / ( ( h + k ) * m ) );
		s += u;
		k = abs( u );
		if ( k > umax ) {
			umax = k;
		}
		i += 1;
		if ( i > MAX_ITERATIONS ) {
			loss.v = 1.0;
			return s;
		}
	} while ( s === 0 || abs( u / s ) > MACHEP );

	loss.v = ( ( MACHEP * umax ) / abs( s ) ) + ( MACHEP * i );

	return s;
}

/**
* Evaluates the Gaussian hypergeometric function.
*
* @private
* @param {number} a - input value
* @param {number} b - input value
* @param {number} c - input value
* @param {number} x - input value
* @param {Object} loss - loss
* @returns {number} function value
*
*/
function hyp2f1ra( a, b, c, x, loss ) {
	var err;
	var da;
	var f0;
	var f1;
	var f2;
	var n;
	var t;

	err = {
		'v': 0.0
	};

	if ( (c < 0 && a <= c) || ( c >= 0 && a >= c ) ) {
		da = round( a - c );
	} else {
		da = round( a );
	}
	t = a - da;

	loss.v = 0.0;

	// Assert: assert ( da != 0 )
	if ( abs( da ) > MAX_ITERATIONS ) {
		// Give up, too expensive to compute
		loss.v = 1.0;
		return NaN;
	}

	if ( da < 0 ) {
		// Recurse down
		f2 = 0.0;
		f1 = hys2f1( t, b, c, x, err );
		loss.v += err.v;
		f0 = hys2f1( t-1.0, b, c, x, err );
		loss.v += err.v;
		t -= 1.0;
		for (n = 1; n < -da; n++ ) {
			f2 = f1;
			f1 = f0;
			f0 = -(((2.0*t)-c-(t*x)+(b*x))/(c-t)*f1)-
                 (t*(x-1)/(c-t)*f2);
			t -= 1.0;
		}
	} else {
		// Recurse up
		f2 = 0.0;
		f1 = hys2f1( t, b, c, x, err );
		loss.v += err.v;
		f0 = hys2f1( t + 1, b, c, x, err );
		loss.v += err.v;
		t += 1.0;
		for ( n = 1; n < da; n++ ) {
			f2 = f1;
			f1 = f0;
			f0 = -(((((2*t)-c-(t*x)+(b*x))*f1)+(c-t))*f2)/
				(t*(x-1.0));
			t += 1.0;
		}
	}
	return f0;
}

/**
* Evaluates the Gaussian hypergeometric function.
*
* @private
* @param {number} a - input value
* @param {number} b - input value
* @param {number} c - input value
* @param {number} x - input value
* @param {Object} loss - loss
* @returns {number} function value
*
*/
function hyt2f1( a, b, c, x, loss ) {
	return a + b + c + x + loss.v;

	/*
	THIS IS OLD STUFF
	var negIntA;
	var negIntB;
	var sign;
	var aid;
	var err1;
	var err;
	var d1;
	var d2;
	var ax;
	var id;
	var ia;
	var ib;
	var y1;
	var p;
	var q;
	var r;
	var s;
	var t;
	var y;
	var w;
	var d;
	var e;
	var i;

	negIntA = 0;
	negIntB = 0;
	ia = 0;
	ib = 0;

	ia = round( a );
	ib = round( b );

	if ( a <= 0 && abs( a - ia ) < EPS ) { // a is negative integer
		negIntA = 1;
	}

	if ( b <= 0 && abs( b - ib ) < EPS ) { // b is negative integer
		negIntB = 1;
	}

	err.v = 0.0;
	s = 1.0 - x;

	if ( x < -0.5 && !( negIntA || negIntB ) ) {
		if ( b > a ) {
	    	y = pow( s, -a ) * hys2f1( a, c - b, c, -x / s, err );
		}
		y = pow( s, -b ) * hys2f1( c - a, b, c, -x / s, err );
		// CEPHES: goto done
		loss.v = err.v;
		return y;
	}

	d = c - a - b;
	id = round( d );
	*/
}

module.exports = {
	'hyt2f1': hyt2f1,
	'hys2f1': hys2f1
};
